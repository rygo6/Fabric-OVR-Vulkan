#version 450
#extension GL_EXT_mesh_shader : require

/* https://developer.nvidia.com/blog/introduction-turing-mesh-shaders/
	"We recommend using up to 64 vertices and 126 primitives"
*/
#include "node_mesh_constants.glsl"
#include "global_ubo.glsl"
#include "node_mesh_ubo.glsl"

layout(local_size_x = VERTEX_DIMENSION_COUNT, local_size_y = VERTEX_DIMENSION_COUNT, local_size_z = 1) in;
layout(triangles, max_vertices = VERTEX_COUNT, max_primitives = PRIMITIVE_COUNT) out;

layout(location = 0) out VertexOutput {
	vec4 color;
} vertexOutput[];

void main()
{
	SetMeshOutputsEXT(VERTEX_COUNT, PRIMITIVE_COUNT);

	const float zOffset = gl_GlobalInvocationID.x * .00001;
	const mat4 mvp = globalUBO.proj * globalUBO.view;
	const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
	const vec2 uv = ((gl_GlobalInvocationID.xy - gl_WorkGroupID.xy) * SCALE) / screenSize;
	const vec2 invUv = vec2(uv.x, 1 - uv.y);
	const vec2 coord = vec2(1, -1) * (uv * 2 - 1);
	const vec4 colorValue = texture(nodeColor, invUv);
	const float depthValue = texture(nodeDepth, invUv).r;

	// TODO GET RID OF MATH
	// Calculate clip space coordinates
	vec4 clipPos = vec4(invUv * 2.0 - 1.0, depthValue, 1.0);
	// Convert clip space coordinates to eye space coordinates
	vec4 eyePos = inverse(nodeUBO.proj) * clipPos;
	// Divide by w component to obtain normalized device coordinates
	vec3 ndcPos = eyePos.xyz / eyePos.w;
	// Convert NDC coordinates to world space coordinates
	vec4 worldPos = inverse(nodeUBO.view) * vec4(ndcPos, 1.0);

	if (colorValue.a == 0)
			return;

//	gl_MeshVerticesEXT[gl_LocalInvocationIndex].gl_Position = vec4(coord, 1, 1);
	gl_MeshVerticesEXT[gl_LocalInvocationIndex].gl_Position = globalUBO.proj * globalUBO.view * worldPos;
//	gl_MeshVerticesEXT[gl_LocalInvocationIndex].gl_Position = colorValue.a > 0 ?
//		globalUBO.proj * globalUBO.view * worldPos :
//		vec4(coord, 1, 1);

//	vertexOutput[gl_LocalInvocationIndex].color = vec4(float(gl_GlobalInvocationID.x) / 1920, float(gl_GlobalInvocationID.y) / 1080, 0.0, 1.0);
	vertexOutput[gl_LocalInvocationIndex].color = colorValue;

	if (gl_LocalInvocationID.x < VERTEX_DIMENSION_COUNT - 1 && gl_LocalInvocationID.y < VERTEX_DIMENSION_COUNT - 1) {
		const uint yOffset = gl_LocalInvocationID.y * VERTEX_DIMENSION_COUNT;
		const uint offsetX = gl_LocalInvocationID.x + yOffset;
		const uint pi = (gl_LocalInvocationID.y * (VERTEX_DIMENSION_COUNT - 1)) + gl_LocalInvocationID.x;
		gl_PrimitiveTriangleIndicesEXT[pi] = uvec3(offsetX, offsetX + 1, offsetX + VERTEX_DIMENSION_COUNT);
		gl_PrimitiveTriangleIndicesEXT[pi + HALF_PRIMITIVE_COUNT] = uvec3(offsetX + 1, offsetX + VERTEX_DIMENSION_COUNT + 1, offsetX + VERTEX_DIMENSION_COUNT);
	}
}