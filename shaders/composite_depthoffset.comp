#version 450

#define FRAME_WIDTH 1920
#define FRAME_HEIGHT 1080

#define LOCAL_SIZE 32

layout (set = 0, binding = 0) uniform GlobalUBO {
    mat4 view;
    mat4 proj;
} globalUBO;

layout (set = 1, binding = 0) uniform sampler2D inputColor;
layout (set = 1, binding = 1) uniform sampler2D inputNormal;
layout (set = 1, binding = 2) uniform sampler2D inputGBuffer;
layout (set = 1, binding = 3) uniform sampler2D inputDepth;

layout (set = 1, binding = 4, rgba8) uniform writeonly image2D outputColor;

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

float linearize_depth(float d,float zNear,float zFar)
{
    return zNear * zFar / (zFar + d * (zNear - zFar));
}

vec4 calcWorldPos(vec2 outUV, float depthValue) {
    // Calculate clip space coordinates
    vec4 clipPos = vec4(outUV * 2.0 - 1.0, depthValue, 1.0);
    // Convert clip space coordinates to eye space coordinates
    vec4 eyePos = inverse(globalUBO.proj) * clipPos;
    // Divide by w component to obtain normalized device coordinates
    vec3 ndcPos = eyePos.xyz / eyePos.w;
    // Convert NDC coordinates to world space coordinates
    vec4 worldPos = inverse(globalUBO.view) * vec4(ndcPos, 1.0);

    return worldPos;
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(float(gl_GlobalInvocationID.x) / float(FRAME_WIDTH), float(gl_GlobalInvocationID.y) / float(FRAME_HEIGHT));

    vec4 color = texture(inputColor, uv);
    float depth = texture(inputDepth, uv).a;
    float linearDepth = linearize_depth(depth, 0.01, 10000.0f);
    vec3 worldNormal = texture(inputNormal, uv).rgb; // needs to not be normal but angle to camera pinhole
    float nodeDepth = texture(inputGBuffer, uv).a;

    float depthDiff = nodeDepth - depth;

    vec4 worldPos = calcWorldPos(uv, depth);
    vec3 newWorldPos = worldPos.xyz + (depthDiff * worldNormal);
    vec4 newClipPos = globalUBO.proj * globalUBO.view * vec4(newWorldPos, 1);
    vec2 newUV = (newClipPos.xy + 1.0) * 0.5;

    vec4 newColor = texture(inputColor, newUV);
    vec3 sRGB = pow(newColor.rgb, vec3(1.0 / 2.2));
    vec3 sRGBswapped = sRGB.bgr;

//    imageStore(outputColor, coord, vec4(sRGBswapped.rgb, pixel.a));
    imageStore(outputColor, coord, color);
}